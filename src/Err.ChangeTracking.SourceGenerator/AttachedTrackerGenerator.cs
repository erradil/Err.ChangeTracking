using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Err.ChangeTracking.SourceGenerator;

/// <summary>
///     Source generator that implements IAttachedTracker for classes implementing ITrackable
/// </summary>
[Generator]
public class AttachedTrackerGenerator : IIncrementalGenerator
{
    #region Initialization

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Set up the pipeline for types implementing ITrackable<T>
        var trackableTypes =
            context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => IsPartialClassDeclaration(node),
                    transform: static (ctx, _) => ExtractTypeInfo(ctx))
                .Where(static t => t is not null);

        // Register the source output
        context.RegisterSourceOutput(trackableTypes, static (ctx, typeInfo) => GenerateSource(ctx, typeInfo!.Value));
    }

    /// <summary>
    /// Check if the node is a partial class/record declaration
    /// </summary>
    private static bool IsPartialClassDeclaration(SyntaxNode node)
    {
        if (node is not TypeDeclarationSyntax typeDecl)
            return false;

        // Must have partial modifier
        if (!typeDecl.Modifiers.Any(SyntaxKind.PartialKeyword))
            return false;

        // Must have a base list (to potentially implement ITrackable)
        return typeDecl.BaseList is not null;
    }

    /// <summary>
    /// Transform the GeneratorSyntaxContext to get the type information
    /// </summary>
    private static TypeInfo? ExtractTypeInfo(GeneratorSyntaxContext ctx)
    {
        if (ctx is not { Node: TypeDeclarationSyntax _, SemanticModel: var semanticModel })
            return null;

        var typeDecl = (TypeDeclarationSyntax)ctx.Node;
        var typeSymbol = semanticModel.GetDeclaredSymbol(typeDecl) as INamedTypeSymbol;

        if (typeSymbol == null)
            return null;

        // Check if the type implements ITrackable<T>
        var implementsTrackable = typeSymbol.AllInterfaces.Any(i =>
            i.OriginalDefinition.ToDisplayString() == Constants.Types.ITrackableFullName);

        if (!implementsTrackable)
            return null;

        // Check if already implements IAttachedTracker<T>
        var alreadyImplementsAttachedTracker = typeSymbol.AllInterfaces.Any(i =>
            i.OriginalDefinition.ToDisplayString() == Constants.Types.IAttachedTrackerFullName);

        if (alreadyImplementsAttachedTracker)
            return null; // Skip if already implemented

        // Use TypeHelper to extract all information
        var typeHelper = new TypeHelper(typeSymbol);
        var typeInfo = typeHelper.GetTypeInfo();

        return typeInfo;
    }

    #endregion

    #region Main Generation

    /// <summary>
    /// Generate source code for a type
    /// </summary>
    private static void GenerateSource(SourceProductionContext context, TypeInfo typeInfo)
    {
        var sourceBuilder = new StringBuilder(1024); // Pre-allocate a reasonable buffer size
        var typeDisplay = new TypeDisplayHelper(typeInfo);

        GenerateFileHeader(sourceBuilder);

        // Add namespace if needed
        if (typeInfo.Namespace != null)
        {
            sourceBuilder
                .AppendLine("using Err.ChangeTracking;")
                .AppendLine()
                .AppendLine($"namespace {typeInfo.Namespace};")
                .AppendLine();
        }

        // Generate the type with all nested hierarchy if needed
        GenerateTypeWithContainingTypes(sourceBuilder, typeInfo);

        var fileName = $"{typeDisplay.GetFullName()}.AttachedTracker.g.cs";
        context.AddSource(fileName, SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
    }

    /// <summary>
    /// Generate the file header with auto-generated comments and nullable enable directive
    /// </summary>
    private static void GenerateFileHeader(StringBuilder sourceBuilder)
    {
        sourceBuilder.AppendLine(
            """
            #pragma warning disable CS8601 // Possible null reference assignment.
            #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.
            // <auto-generated>
            // This code was generated by the Err.ChangeTracking.AttachedTracker Source Generator
            // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated
            // </auto-generated>
            #nullable enable
            """);
    }

    #endregion

    #region Type Generation

    /// <summary>
    /// Generate a type with all its containing types if needed
    /// </summary>
    private static void GenerateTypeWithContainingTypes(
        StringBuilder sourceBuilder,
        TypeInfo typeInfo)
    {
        // Indent management
        var indent = 0;
        var typeDisplay = new TypeDisplayHelper(typeInfo);

        // For nested types, generate the containing type hierarchy first
        if (typeInfo.ContainingTypeInfos.Count > 0)
        {
            // For each containing type, open a partial type declaration
            foreach (var containingType in typeInfo.ContainingTypeInfos)
            {
                var indentStr = GetIndentation(indent);
                var containingTypeDisplay = new ContainingTypeDisplayHelper(containingType);
                sourceBuilder.AppendLine($"{indentStr}{containingTypeDisplay.ToDisplayDeclaration()}")
                    .AppendLine($"{indentStr}{{");

                indent++;
            }
        }

        // Get the indent for the current type
        var typeIndent = GetIndentation(indent);

        // Generate the main type with IAttachedTracker interface
        var typeName = typeInfo.Name;
        var accessibility = GetAccessibilityString(typeInfo.Accessibility);
        var modifiers = string.Join(" ", typeInfo.Modifiers);
        var modifiersWithSpace = modifiers.Length > 0 ? $"{modifiers} " : "";

        sourceBuilder.AppendLine($"{typeIndent}// Auto-generated IAttachedTracker implementation for {typeName}")
            .AppendLine($"{typeIndent}{accessibility} {modifiersWithSpace}partial {typeInfo.Kind} {typeName} : {Constants.Types.IAttachedTrackerFullName.Replace("<TEntity>", $"<{typeName}>")}")
            .AppendLine($"{typeIndent}{{");

        indent++;
        var contentIndent = GetIndentation(indent);

        // Generate IAttachedTracker.ChangeTracker property with explicit interface implementation
        sourceBuilder
            .AppendLine($"{contentIndent}// Attaches inline change tracker to instance (direct field access, faster than cache-based tracking (default))")
            .AppendLine($"{contentIndent}IChangeTracker<{typeName}>? IAttachedTracker<{typeName}>.ChangeTracker {{ get; set; }}");

        // Close all type declarations (the current type + any containing types)
        for (var i = indent; i > 0; i--)
            sourceBuilder.AppendLine($"{GetIndentation(i - 1)}}}");
    }

    /// <summary>
    /// Get indentation string for the specified level
    /// </summary>
    private static string GetIndentation(int level)
    {
        return new string(' ', level * 4);
    }

    /// <summary>
    /// Convert an accessibility level to its string representation
    /// </summary>
    private static string GetAccessibilityString(Accessibility accessibility)
    {
        return accessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Protected => "protected",
            Accessibility.Internal => "internal",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.ProtectedAndInternal => "private protected",
            Accessibility.Private => "private",
            _ => ""
        };
    }

    #endregion
}
