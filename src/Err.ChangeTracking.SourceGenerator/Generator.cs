using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Err.ChangeTracking.SourceGenerator;

/// <summary>
///     Source generator that implements partial properties with change tracking
/// </summary>
[Generator]
public class ChangeTrackingGenerator : IIncrementalGenerator
{
    #region Initialization

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Set up the pipeline for the Trackable attribute
        var trackableTypes =
            context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    Constants.Types.TrackableAttributeFullName,
                    static (node, _) =>
                        node is TypeDeclarationSyntax typeDecl && HasPartialModifier(typeDecl),
                    static (ctx, _) => ExtractTypeInfo(ctx))
                .Where(static t => t is not null);

        // Register the source output
        context.RegisterSourceOutput(trackableTypes, static (ctx, typeInfo) => GenerateSource(ctx, typeInfo!.Value));
    }

    /// <summary>
    /// Check if the node has a partial modifier
    /// </summary>
    private static bool HasPartialModifier(TypeDeclarationSyntax typeDecl)
    {
        return typeDecl.Modifiers.Any(SyntaxKind.PartialKeyword);
    }

    /// <summary>
    /// Transform the GeneratorAttributeSyntaxContext to get the type information
    /// </summary>
    private static TypeInfo? ExtractTypeInfo(GeneratorAttributeSyntaxContext ctx)
    {
        if (ctx is not { TargetNode: TypeDeclarationSyntax _, TargetSymbol: INamedTypeSymbol typeSymbol })
        {
            return null;
        }

        // Use TypeHelper to extract all information
        var typeHelper = new TypeHelper(typeSymbol);
        var typeInfo = typeHelper.GetTypeInfo();

        // Only process types with at least one trackable property
        if (typeInfo.Properties.IsEmpty)
            return null;

        return typeInfo;
    }

    #endregion

    #region Main Generation

    /// <summary>
    /// Generate source code for a type
    /// </summary>
    private static void GenerateSource(SourceProductionContext context, TypeInfo typeInfo)
    {
        var sourceBuilder = new StringBuilder(2048); // Pre-allocate a reasonable buffer size
        var typeDisplay = new TypeDisplayHelper(typeInfo);

        GenerateFileHeader(sourceBuilder);

        // Add namespace if needed
        if (typeInfo.Namespace != null)
        {
            sourceBuilder
                .AppendLine("using Err.ChangeTracking;")
                .AppendLine()
                .AppendLine($"namespace {typeInfo.Namespace};")
                .AppendLine();
        }

        // Generate the type with all nested hierarchy if needed
        GenerateTypeWithContainingTypes(sourceBuilder, typeInfo);

        var fileName = $"{typeDisplay.GetFullName()}.g.cs";
        context.AddSource(fileName, SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
    }

    /// <summary>
    /// Generate the file header with auto-generated comments and nullable enable directive
    /// </summary>
    private static void GenerateFileHeader(StringBuilder sourceBuilder)
    {
        sourceBuilder.AppendLine(
            """
            #pragma warning disable CS8601 // Possible null reference assignment.
            #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.
            // <auto-generated>
            // This code was generated by the Err.ChangeTracking Source Generator
            // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated
            // </auto-generated>
            #nullable enable
            """);
    }

    #endregion

    #region Type Generation

    /// <summary>
    /// Generate a type with all its containing types if needed
    /// </summary>
    private static void GenerateTypeWithContainingTypes(
        StringBuilder sourceBuilder,
        TypeInfo typeInfo)
    {
        // Indent management
        var indent = 0;
        var typeDisplay = new TypeDisplayHelper(typeInfo);

        // For nested types, generate the containing type hierarchy first
        if (typeInfo.ContainingTypeInfos.Count > 0)
        {
            // For each containing type, open a partial type declaration
            foreach (var containingType in typeInfo.ContainingTypeInfos)
            {
                var indentStr = GetIndentation(indent);
                var containingTypeDisplay = new ContainingTypeDisplayHelper(containingType);
                sourceBuilder.AppendLine($"{indentStr}{containingTypeDisplay.ToDisplayDeclaration()}")
                    .AppendLine($"{indentStr}{{");

                indent++;
            }
        }

        // Get the indent for the current type
        var typeIndent = GetIndentation(indent);

        // Generate the main type
        sourceBuilder.AppendLine($"{typeIndent}// Auto-generated implementation for {typeInfo.Name}")
            .AppendLine($"{typeIndent}{typeDisplay.ToDisplayDeclaration()}")
            .AppendLine($"{typeIndent}{{");

        indent++;
        var contentIndent = GetIndentation(indent);

        // Generate static constructor for deep tracking if needed
        var staticCtor = typeDisplay.ToDisplayStaticConstructor(contentIndent);
        if (!string.IsNullOrEmpty(staticCtor)) sourceBuilder.AppendLine(staticCtor);

        // Generate all trackable properties
        GenerateProperties(sourceBuilder, typeInfo, contentIndent);

        // Close all type declarations (the current type + any containing types)
        for (var i = indent; i > 0; i--) sourceBuilder.AppendLine($"{GetIndentation(i - 1)}}}");
    }

    /// <summary>
    ///     Generate all properties for a type
    /// </summary>
    private static void GenerateProperties(StringBuilder sourceBuilder, TypeInfo typeInfo, string indent)
    {
        foreach (var property in typeInfo.Properties)
        {
            if (!property.IsAlreadyTrackableCollection)
            {
                var propertyDisplay = new PropertyDisplayHelper(property);
                sourceBuilder.AppendLine(propertyDisplay.ToDisplayFullProperty(indent));
            }
        }
    }

    /// <summary>
    /// Get indentation string for the specified level
    /// </summary>
    private static string GetIndentation(int level)
    {
        return new string(' ', level * 4);
    }

    #endregion
}